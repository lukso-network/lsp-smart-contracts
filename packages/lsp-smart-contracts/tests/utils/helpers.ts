import {
  BytesLike,
  AbiCoder,
  Wallet,
  toBigInt,
  zeroPadValue,
  toBeHex,
  getNumber,
  concat,
  solidityPacked,
} from 'ethers';
import hre from 'hardhat';
const {
  ethers: { provider: hreProvider },
} = hre;

// constants
import { LSP25_VERSION } from '@lukso/lsp25-contracts';
import { EIP191Signer } from '@lukso/eip191-signer.js';

export const abiCoder = AbiCoder.defaultAbiCoder();
export const provider = hreProvider;

export const AddressOffset = '000000000000000000000000';
export const EMPTY_PAYLOAD = '0x';

export const LSP1_HOOK_PLACEHOLDER =
  '0xffffffffffffffff0000000000000000aaaaaaaaaaaaaaaa1111111111111111';

/**
 * Private keys for the accounts used in the tests.
 * These are the private keys for the accounts generated by the hardhat node (local blockchain).
 * The private keys are used to sign messages with lsp6-signers.js library.
 *
 * WARNING! These private keys and their related accounts are publicly known and should never be used in production.
 *          Any funds sent to them on Mainnet or any other live network WILL BE LOST.
 */
export const LOCAL_PRIVATE_KEYS = {
  ACCOUNT0: '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  ACCOUNT1: '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',
  ACCOUNT2: '0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a',
  ACCOUNT3: '0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6',
  ACCOUNT4: '0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a',
  ACCOUNT5: '0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba',
  ACCOUNT6: '0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e',
  ACCOUNT7: '0x030ab56c9834360e1c0dba6b9a955b6e127f3166cda462c2472f67e1ba773053',
};

// bytes32 arraylength
export const ARRAY_LENGTH = {
  ZERO: '0x00000000000000000000000000000000',
  ONE: '0x00000000000000000000000000000001',
  TWO: '0x00000000000000000000000000000002',
  THREE: '0x00000000000000000000000000000003',
  FOUR: '0x00000000000000000000000000000004',
  FIVE: '0x00000000000000000000000000000005',
  SIX: '0x00000000000000000000000000000006',
  SEVEN: '0x00000000000000000000000000000007',
  EIGHT: '0x00000000000000000000000000000008',
};

export function getRandomAddresses(count: number): string[] {
  const addresses: string[] = [];
  for (let ii = 0; ii < count; ii++) {
    // addresses stored under ERC725Y storage have always lowercases character.
    // therefore, disable the checksum by converting to lowercase to avoid failing tests
    const randomAddress = Wallet.createRandom().address.toLowerCase();
    addresses.push(randomAddress);
  }

  return addresses;
}

export function combinePermissions(..._permissions: string[]) {
  let result: bigint = toBigInt(0);

  _permissions.forEach((permission) => {
    const permissionAsBN = toBigInt(permission);
    result = result | permissionAsBN;
  });

  return zeroPadValue(toBeHex(result), 32);
}

export function combineCallTypes(..._callTypes: string[]) {
  let result: bigint = toBigInt(0);

  _callTypes.forEach((callType) => {
    const callTypeAsBN = toBigInt(callType);
    result = result | callTypeAsBN;
  });

  return zeroPadValue(toBeHex(result), 4);
}

export function encodeCompactBytesArray(inputKeys: BytesLike[]) {
  let compactBytesArray = '0x';
  for (let i = 0; i < inputKeys.length; i++) {
    compactBytesArray +=
      zeroPadValue(toBeHex(inputKeys[i].toString().substring(2).length / 2), 2).substring(2) +
      inputKeys[i].toString().substring(2);
  }

  return compactBytesArray;
}

export function decodeCompactBytes(compactBytesArray: BytesLike) {
  let pointer = 2;
  const keysToExport: BytesLike[] = [];
  while (pointer < compactBytesArray.length) {
    const length = getNumber('0x' + compactBytesArray.toString().substring(pointer, pointer + 4));
    keysToExport.push(
      '0x' + compactBytesArray.toString().substring(pointer + 4, pointer + 2 * (length + 2)),
    );

    pointer += 2 * (length + 2);
  }
  return keysToExport;
}

export function combineAllowedCalls(
  _allowedInteractions: string[],
  _allowedAddresses: string[],
  _allowedStandards: string[],
  _allowedFunctions: string[],
) {
  let result = '0x0020';

  for (let ii = 0; ii < _allowedStandards.length; ii++) {
    // remove "0x" prefixes
    const allowedInteractions = _allowedInteractions[ii].substring(2);
    const allowedAddress = _allowedAddresses[ii].substring(2).toLowerCase();
    const allowedStandard = _allowedStandards[ii].substring(2);
    const allowedFunction = _allowedFunctions[ii].substring(2);

    result = result + allowedInteractions + allowedAddress + allowedStandard + allowedFunction;

    if (ii != _allowedStandards.length - 1) {
      result = result + '0020';
    }
  }

  return result;
}

export function createValidityTimestamps(
  startingTimestamp: number,
  endingTimestamp: number,
): bigint {
  const concatenatedHex = concat([
    zeroPadValue(toBeHex(startingTimestamp), 16),
    zeroPadValue(toBeHex(endingTimestamp), 16),
  ]);
  return toBigInt(concatenatedHex);
}

export async function signLSP6ExecuteRelayCall(
  _keyManager,
  _signerNonce: string | bigint,
  _signerValidityTimestamps: BytesLike | number | bigint,
  _signerPrivateKey: string,
  _msgValue: number | bigint | string,
  _payload: string,
) {
  const signedMessageParams = {
    lsp25Version: LSP25_VERSION,
    chainId: 31337, // HARDHAT_CHAINID
    nonce: _signerNonce,
    validityTimestamps: _signerValidityTimestamps,
    msgValue: _msgValue,
    payload: _payload,
  };

  const encodedMessage = solidityPacked(
    ['uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'bytes'],
    [
      signedMessageParams.lsp25Version,
      signedMessageParams.chainId,
      signedMessageParams.nonce,
      signedMessageParams.validityTimestamps,
      signedMessageParams.msgValue,
      signedMessageParams.payload,
    ],
  );

  const eip191Signer = new EIP191Signer();

  const { signature } = await eip191Signer.signDataWithIntendedValidator(
    await _keyManager.getAddress(),
    encodedMessage,
    _signerPrivateKey,
  );

  return signature;
}
